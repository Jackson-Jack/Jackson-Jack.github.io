<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[在写一个iOS应用之前必须做的7件事]]></title>
      <url>%2F2017%2F04%2F07%2F7-Things-you-must-absolutely-do-before-writing-an-iOS-app%2F</url>
      <content type="text"><![CDATA[转自CocoaChina翻译活动 英文原文：7 Things you must absolutely do before writing an iOS app 这两年，我一直在编写并发布有质量的iOS 应用。我发现大多数的开发人员有直接跳进编码应用程序的核心逻辑的倾向，因为这是乐趣所在。遵循流程开发是很无聊的。 我了解到最有效的方式是，如果你提前花些时间正确设置项目，你将会为将来节省大量的时间。如果你是一位独立开发者，你可能意识不到下面提到的这些步骤的重要性。大多数优秀的应用程序都由团队开发，如果遵循以下步骤，肯定能帮你减少挫败感并提升应用质量。 1.为工程设置编码风格规范编码风格规范指的是在使用特定语言写代码之前要明确遵守的风格和惯例，它包括类似于该使用tab键还是空格键，如何命名变量以及特定语言本身的约定俗成（像swift语言中是否该使用Classes还是Structs）。 编码规范本身没有孰对孰错。在项目开始前，你可以设置自己的编码风格，但是必须保证同组的人遵守相同的规范。编码规范能够保证代码更加统一和更易于阅读。 一些公司已经开源了Objective-C和Swift语言的编码规范。 Ray Wenderlich/Swift Style Guide GitHub/swift-style-guide NYTimes/objective-c-style-guide 2.在写代码之前确定应用的架构在写代码之前，确定应用架构是非常重要的。一个好的架构可以提升应用的可测试性，更加易于理解并且能降低维护成本。你可以使用传统的MVC架构，或者使用更加流行的MVVM或VIPER架构，这里提供了大量的资源来介绍这些架构。 iOS Architecture Patterns（中文版：iOS 架构模式–解密 MVC，MVP，MVVM以及VIPER架构） Issue 13 Architecture *objc.io Modern application architectures (Reactive programming, MVVM and beyond) 3.设定应用的目录结构为了使数以百计的源代码文件至始至终保存在相同的目录中，最好是根据项目的架构制定目录结构，例如，你可以使用以下的目录结构： 首先，在Xcode的Project Navigator中工程名称分组下面，以group的形式创建它们（小黄色的文件夹），然后，通过打开Xcode右边的File Inspector，为每个创建的group链接到真实的项目路径下对应的目录，点击File Inspector中小的灰色的文件夹icon，在工程目录下创建对应group名称的子目录。 这个看起来是件小的事情，却可以使你的项目更加有条理且易于理解。 了解更多目录结构可以参考以下资源： futurice/ios-good-practices 4.项目依赖管理你当然会在项目中使用第三方库，在项目中，你可以有三种方式可以管理项目依赖。 CocoaPodsCocoaPods是适用于Swift和Objective-C Cocoa项目的依赖管理库，它有将近10000个开源库，可以优雅地帮你管理项目的规模。它是最有效的方式做依赖管理，就像Ruby中的Gems。 Youtube上有一个google开发者创建的滑稽的视频（地址，需翻墙）来解释为什么必须在项目中使用CocoaPods。 Github Submodules你也可以使用Github Submodules管理你的项目依赖作为子库，相比CocoaPods，Github Submodules的优点在于它是sub-repos- 这不仅意味着git和git GUIs能够隐式识别他们，并且也可以获得更多支持，同时意味着你的工程依赖能够更加紧密的联系到他们的git仓库，而Cocoapods则不能。 submodules的问题是：你的工程不拥有你依赖库的源代码，仅仅是拥有一个引用到submodule的仓库。大多数情况你控制不了这些代码仓库。 Carthage Carthage被认为是往Cocoa应用中添加框架的最简单的方法。Carthage使用xcodebuild编译framework二进制，但是把集成的任务留给了用户。CocoaPods的目的是对用户简单，但是Carthage对用户来说是灵活的、不干涉的。 不幸的是，Carthage的最大的缺点是—-只支持iOS8及以后版本。 这三个当中，我最常用并且我个人最喜欢的是CocoaPods，因为它设置超级简单，并且提供了数以千计的第三方库供你访问。 5.为应用设置合适的Scheme当你点击了Run、Test、Profile、Analyze或者Archive 操作后，Schemes告诉Xcode什么会发生。通常，每个操作对应一个target和一个编译配置。你也可以传递启动参数，比如应用运行的语言(测试本地化很有用)或者debug时设置一些判断的标识位。 建议Scheme的命名规则采用MyApp () [Environment]: 你也可以使用Target制作不同的发布、测试以及开发来编译程序，如以下描述： How to Use Xcode Targets to Manage Development and Production Builds 6.设置合适的Certificates和Provisioning Profiles在测试和发布应用过程中，这个是开发者最头疼且重要的步骤。证书对代码签名来说是必须的，你可以在真机上运行应用程序。 有两种类型的证书： 开发证书：每个团队的开发者都有自己的证书，需要请求生成。Xcode会为你做这些，但是最好不要点击“Fix issue”按钮，并且能够理解点击这个按钮会真正执行什么。开发证书是发布应用的开发版本到设备上。 发布证书：可以有多个，但是最好保持一个公司一个发布证书，通过内部渠道分享相关的秘钥。发布应用到App Store时需要这个证书，或者是公司内部的企业级应用分发。 Provisioning Profiles 可能是系统中最容易引起混淆的部分了，如果你访问苹果开发者网站，你会注意到你可以创建两种类型的Provisioning Profiles（开发和发布）。Provisioning Profiles是“以这个证书的私钥作为签名的应用可以在这些设备上正常运行: https://www.quora.com/What-are-the-differences-between-certificates-provisioning-profiles-and-identifiers 你可以阅读更多相关资源: Maintaining Your Signing Identities and Certificates What is a Provisioning Profile? Part 2 7.设置应用持续集成和交付过程建立一个持续集成和交付过程已成为关键，因为现在它可以帮助您在开发早期发现bug和节省大量的开发人员的时间。 持续集成 (CI) 是一种开发实践，要求开发人员一天将代码同步到共享存储库几次。每次提交都会用自动脚本进行验证，可以使团队尽早的发现问题。 很多工具可以帮你做iOS应用程序的持续集成，比如 Xcode Server、Jenkins和Travis CI。 About Continuous Integration in Xcode Travis-CI:Test and Deploy with Confidence iOS CI with Jenkins 持续交付 (CD) 是一个软件工程的方式，可以使团队在短周期内开发软件，确保软件可以在任何时间可靠地发布。它旨在更快、更频繁地构建、测试和发布的软件。 为什么使用持续交付？ 可以在准备应用提交、上传截图以及发布应用上节省数天时间。 如果在同事休假期间，但你发现一个严重问题需要修复并发布怎么办？在发布更新版本时不需要依赖某一个人。 通过更频繁和小版本的更新，提高软件质量和反应时间。 虽然有大量的工具供持续交付，我个人最喜欢的是Fastlane。它非常容易安装，并提供了一些强大的功能，可以使你整个的编译和发布过程自动化。 Fastlane]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈加密与解密]]></title>
      <url>%2F2017%2F01%2F20%2Fencryption-and-decryption%2F</url>
      <content type="text"><![CDATA[这几个概念在金融电子支付领域用得比较多，我忽然觉得把它们串起来一起讲,层层引入，可能更好理解一些。希望能以最简单朴实的方式讲明白他们之间的关系。 非对称算法关于非对称算法，你只要知道下面这些就行了，密钥是一对，一个叫公钥，一个叫私钥，前者公开，后者保密。假设你有一对公私钥，给你一串数据，你可以用私钥加密，然后把密文和公钥都放出去，别人可以用这个公钥解密。同样反过来，别人也可以用这个公钥加密一串数据，你用对应的私钥解密。可以用下图来表示: 散列散列也叫哈希，学过数据结构的人对这个概念都不陌生。简单来讲，给你一串数据A，这个数据可以很长，你通过一个算法把它们转变成一个很短的固定长度（不管源串有多长）的另一串数据B。这个过程就叫散列，数据B叫数据A的散列值(或者叫哈希值，或者叫摘要)。 再深入一些。大部分情况下，A和B是一一对应的（这也是我们希望的），也就是说，如果我还有个A1,那么它的散列值B1和B不会相等。但是理想丰满，现实让人反感，B1有可能和B相等。这种现象有个学名叫”碰撞”，增加散列值的位数是防碰撞的一个方法，因为很自然位数越长，完全相同的概率就越小。目前认为超过128位的散列值都能很好的防碰撞。后面我们讲到签名时，假定是没有碰撞的。 最后再补充一点，散列具有不可逆性，也就是你没法从B还原回A,即使散列算法是公开的。 数字签名 生活中我们用签名代表自己的身份，比如领导签署一个文件，大家看到这个签名，就确认是这个领导签的，就代表他本人。签名只占用很小的信息(一般是两个字或三个字，日本人的可能长一些)，却能表示你整个人的信息，这种思想确实意义很大，我们把它用在电子化的签名过程，也就是数字签名。 数字签名的过程是这样的，比如小明有一串数据A要发给小红，小明先用散列生成一个A的摘要B，然后把B用一个私钥加密后附在A的后面发给小红，小红有公钥(因为是公开的)，她先用这个公钥解密A后面的数据得到B，然后自己把A散列一些算出一个B1, 比较B1和B如果相等，首先能说明数据是小明发过来的，因为只有小明才有私钥，其次能说明A在传输过程中没有被改过，因为如果修改过，散列值肯定不相等。 可能有有会有问题，数据A似乎没有加密？，确实是这样，因为这个不是小红所关心的，小红只关心这个数据是不是小明发的，数据的内容没那么重要。其实也不难理解，就跟你去超市刷卡购物一样，小票需要你签字作为对账的凭证，人们只关心这个签名是不是你本人的，对于小票的内容没这么关心。 证书仔细想想上面的验证签名的过程，似乎天衣无缝。但其实有个问题，小红的公钥是哪来的？有人说这个不是公开的吗，随便哪都可以，可以是问别人要的，可以是网上找的。其实不然，验签的前提，是小红已经假设她手上的公钥和小明的私钥是一对的。如果小王生成一对非法的公私钥对，然后给小红公钥，给她说这是小明的，就会产生问题了。所以小红要有明确的途径确认她的公钥是合法的。 打个比方，一个人站在你面前，你没法判断他是好人还是坏人，但是如果法院告诉你这个人是杀人犯，你肯定会选择相信，因为法院是权威机构。同样的，对于公钥这样的”公开的敏感信息”,也需要一个权威机构来认定。这个机构叫CA(certification authority)。这样小红只要是从CA拿的公钥，就可以认为它是合法的了。 CA一般不会直接下发公钥，它通常把公钥信息和一些附加信息(比如公钥产生的日期，有效期等)一起按照一定的格式组织起来下发，这种组织起来的数据就叫做证书。证书的作用就是它有一定的格式，这个格式还是个标准，全世界都用它，这样就很方便传播。目前用得比较多的证书就是著名的x.509。 扩展资料 非对称算法，散列(Hash)以及证书的那些事 数字签名和加密的区别 RSA的公钥和私钥到底哪个才是用来加密和哪个用来解密？ 加密和签名的区别？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 在线视频下载]]></title>
      <url>%2F2016%2F12%2F16%2Fhow-to-download-online-video-with-mac%2F</url>
      <content type="text"><![CDATA[不求最全，只求最简 介绍一个强大的命令行下载工具安装you-get1$ brew install you-get 什么？返回了：-bash: brew: command not found 这么强大的Homebrew 你以前居然没有安装？那就首先安装Homebrew吧！安装成功后再安装you-get 安装Homebrew：(以前已经安装过的，可以跳过)1$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 使用you-get下载在线视频成功安装好you-get后，通过下面命令即可下载对应网站的视频， 1$ you-get -o ~/Downloads online_video_url 使用 -o 设定路径 （小写的字母o） 比如优酷上的一个交通安全日宣传视频对应的地址是:http://v.youku.com/v_show/id_XMTg1MDU3MDQxNg==.html?from=s1.8-1-1.2&amp;spm=a2h0k.8191407.0.0，想下载该视频，则输入下面的样式即可下载成功至~/Downloads该目录下。1$ you-get -o ~/Downloads http://v.youku.com/v_show/id_XMTg1MDU3MDQxNg==.html?from=s1.8-1-1.2&amp;spm=a2h0k.8191407.0.0 BINGO！是不是觉得很简单~ 扩展资料 Homebrew官网 you-get 中文说明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[两步让你的网站支持简体繁体切换]]></title>
      <url>%2F2016%2F10%2F11%2Fhow-set-Chinese-Simplified-switch-to-Chinese-Traditional%2F</url>
      <content type="text"><![CDATA[切换的基本原理，就是首先建立一个简体字与繁体字相对应的一个映射表，然后遍历整个界面，把相应的简体字或者是繁体字映射为对应的字体即可。 不少网站为了更好地照顾不同用户使用简体/繁体的阅读习惯，会提供简体繁体两种版本字体切换，提高用户体验。例如hexo虽然作者是来自台湾的，但是hexo的官网不仅提供了适合台湾同胞阅读的繁体中文版，还提供了适合我们内地同胞阅读的简体中文版，照顾了我们这些习惯使用简体读写的大陆用户，hexo得到了不少内地忠实粉丝追捧。同样，我们也可以提供繁体版来照顾那些使用繁体字的台湾、香港同胞阅读习惯。 具体实现： 首先，点击这里右键另存下载简繁字体切换所需的tw_cn.js文件，上传到自己的网站空间。 其次，修改模板，在你想要显示简繁转换按钮的地方加上下面一段代码。我就直接在footer.swig(我的hexo主题是NexT.Mist，里面布局文件的格式是.swig，其他主题的后缀名可能不相同，找到对应的文件名即可)里添加了如下代码： 123456789101112131415&lt;div class="translate-style"&gt;繁/简：&lt;a id="translateLink" href="javascript:translatePage();"&gt;繁體&lt;/a&gt;&lt;/div&gt;&lt;script type="text/javascript" src="http://www.qingboshare.com/js/src/tw_cn.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0var cookieDomain = "http://www.qingboshare.com/"; //Cookie地址, 一定要设定, 通常为你的网址var msgToTraditionalChinese = "繁體"; //此处可以更改为你想要显示的文字var msgToSimplifiedChinese = "简体"; //同上，但两处均不建议更改var translateButtonId = "translateLink"; //默认互换idtranslateInitilization();&lt;/script&gt; 这就基本完成了简体繁体切换功能,不管你是hexo，jelly，Octopress等静态博客，还是wordpress，typecho，emlog，Z-Blog等动态的，都可以用上。具体的演示效果可以点击我博客底部简体中文切换字体,至于简体繁体切换按钮嘛，文字和样式可以按个人喜好自行更改。这是一篇来源于三步让你的网站支持简体繁体切换 的文章，由于原博客现在展示不了切换效果，我优化了一下文章并添加了切换效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode 调试技巧]]></title>
      <url>%2F2016%2F08%2F17%2Fxcode-debugging%2F</url>
      <content type="text"><![CDATA[从事iOS开发也有好些年了，从最初的不懂得如何调试程序，到后来慢慢学会了用NSLog来调试，再到如今掌握了一些调试技巧，明显感觉到开发效率在提升。现在我就谈一谈Xcode的调试技巧，关于调试技巧，也就是如何使用断点来调试，为了让大家对断点有进一步的认识，我就把断点分为了下面几个类别： 基本断点这种是最常用的断点，也是最容易设置。左键点击一下就可以设置。 编辑断点对基本断点进行编辑，可以生成条件断点、日志信息断点、发声断点等 点击后会弹出如下内容 其中，Condition: 返回一个布尔值，只有在布尔值为真的情况下断点才会触发 Ignore：忽略前n次断点，直到第n+1次遇到断点才触发 Action：断点触发时，Xcode执行的操作，共有六种类型，如下图所示： AppleScript：用于执行脚本，如display dialog “SwiftGG”弹出对话框。 Capture GPU Frame：捕获在断点处 GPU 当前绘制的帧图，用于 OpenGL ES应用的调试。 Debugger Command：相当于在控制台中输入的 lldb 调试命令。 Log Message：将自定义格式、内容的信息输出到控制台，常用的占​​位符有：%H(断点第几次触发)，%B(断点所在的方法的名字)和@expr@(输出expr的值)。 Shell Command：接收命令文件以及相应的参数列表。 Xcode会异步执行 Shell Command。勾选 “Wait until done”表示等待 Shell 命令执行结束后再执行调试工作。 Sound：触发断点的同时播放声音 Automatically continue after evaluating actions：勾选这个选项后，断点不会中断程序运行。 异常断点(Exception Breakpoint)异常断点是代码出现问题导致编译器抛出异常时触发的断点。它在断点导航器中设置。点击＋号，选择Exception Breakpoint选项。如下图所示 点击添加后会出现下面的小框 Exception：选项可以让你选择响应Objective－C对象抛出的异常，也可以选择响应C++对象抛出的异常。 Break：则是选择断点所接收的异常，是接收“Throw”语句抛出的异常还是Catch语句的。 由于有一些异常的出现，是在不满足某些特定条件下而导致的，比如说在复杂循环中数组越界，这个时候往往不容易根据异常信息确定错误的出处，这个时候设置异常断点便能发挥作用。 符号断点（Symbolic Breakpoint）在断点导航器界面，点击＋号，选择Add Symbolic Breakpoint选项 然后会弹出下面所示的对话框 Symbol：用来设置当前断点作用域所能识别的方法，这里面既可以是自定义的方法，也可以是系统的API方法。（注意必须表明是类方法还是成员方法） 例如：在 Symbol 一栏输入 viewDidLoad。这样一来，在程序中所有的 viewDidLoad 方法被调用时都会触发断点。 当然，我们也可以仅仅为特定的某个类的方法添加断点。在 Symbol 一栏输入 [ClassName viewDidLoad] (Objective-C) 或 ClassName.viewDidLoad (Swift) 即可。 监控断点我们调试程序的大部分时候都是为了监控某个变量的变化，在代码中变量出现的地方添加断点不仅累而且还可能漏掉，事后还得一个一个删掉，实在很累。 我们可以通过为变量添加监控断点来简单地做到这一点。找到变量第一次出现的地方，添加一个普通断点，进入 debug 模式后在 Variables View 中右键变量，选择 Watch 变量名。这样，每一次该变量被改变都会触发断点告知我们。 参考链接 WWDC 2013 Debugging with Xcode SwiftGG 交流分享：Xcode使用技巧 Xcode之断点调试详解 Xcode断点调试技巧 Xcode 的正确打开方式——Debugging]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统中的栈和堆]]></title>
      <url>%2F2016%2F07%2F27%2Fstack-and-heap-in-os%2F</url>
      <content type="text"><![CDATA[注：这里所说的堆和栈与数据结构中的堆和栈不是一回事。 我们先来看看一个由C/C++/OBJC编译的程序占用内存分布的结构： 栈区（stack）：由系统自动分配，一般存放函数参数值、局部变量的值等。由编译器自动创建与释放。其操作方式类似于数据结构中的栈，即后进先出、先进后出的原则。 例如：在函数中申明一个局部变量int b;系统自动在栈中为b开辟空间。 堆区（heap）：一般由程序员申请并指明大小，最终也由程序员释放。如果程序员不释放，程序结束时可能会由OS回收。对于堆区的管理是采用链表式管理的，操作系统有一个记录空闲内存地址的链表，当接收到程序分配内存的申请时，操作系统就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后将该节点记录的内存地址分配给程序。 例如：在C中malloc函数 12char p1; p1 = (char )malloc(10); 但是p1本身是在栈中的。 链表：是一种常见的基础数据结构，一般分为单向链表、双向链表、循环链表。以下为单向链表的结构图： 单向链表是链表中最简单的一种，它包含两个区域，一个信息域和一个指针域。信息域保存或显示关于节点的信息，指针域储存下一个节点的地址。 上述的空闲内存地址链表的信息域保存的就是空闲内存的地址。 全局区/静态区：顾名思义，全局变量和静态变量存储在这个区域。只不过初始化的全局变量和静态变量存储在一块，未初始化的全局变量和静态变量存储在一块。程序结束后由系统释放。 文字常量区：这个区域主要存储字符串常量。程序结束后由系统释放。 程序代码区：这个区域主要存放函数体的二进制代码。 下面举一个例子： 1234567891011121314//main.cppint a = 0; // 全局初始化区char *p1; // 全局未初始化区main &#123; int b; // 栈 char s[] = "abc"; // 栈 char *p2; // 栈 char *p3 = "123456"; // 123456\0在常量区，p3在栈上 static int c =0； // 全局静态初始化区 p1 = (char *)malloc(10); p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 strcpy(p1, "123456"); // 123456\0在常量区，这个函数的作用是将"123456" 这串字符串复制一份放在p1申请的10个字节的堆区域中。 // p3指向的"123456"与这里的"123456"可能会被编译器优化成一个地址。&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C中的Block]]></title>
      <url>%2F2016%2F07%2F26%2Fblock-of-objective-c%2F</url>
      <content type="text"><![CDATA[block介绍 Block是iOS4.0之后新增的一种语法结构，也称为“闭包”。 Block是一个匿名的函数代码块，此代码块可以作为参数传递给其他对象。 可以把block当做Objective-C的匿名函数，block是OC中的一种数据类型，^是block的特有标记。 block原型 (返回类型)(^block名称)(参数类型)=^(参数列表){代码实现}; 1NSString * ( ^ myBlock )( int ); 上面的代码声明了一个block(^)原型，名字叫做myBlock，包含一个int型的参数，返回值为NSString类型的指针。block的定义： 1234myBlock = ^( int paramA )&#123; return [NSString stringWithFormat:@"The number is: %i", paramA];&#125;; 上面的代码中，将一个函数体赋值给了myBlock变量，其接收一个名为paramA的参数，返回一个NSString对象. 注意：一定不要忘记block后面的分号。 定义好block后，就可以像使用标准函数一样使用它了： myBlock(6); 由于block数据类型的语法会降低整个代码的阅读性，所以常使用typedef来定义block类型。例如，下面的代码创建了GetPersonEducationInfo和GetPersonFamilyInfo两个新类型，这样我们就可以在下面的方法中使用更加有语义的数据类型。 1234567// Person.htypedef NSString * (^GetPersonEducationInfo)(NSString *);typedef NSString * (^GetPersonFamilyInfo)(NSString *);@interface Person : NSObject- (NSString *)getPersonInfoWithEducation:(GetPersonEducationInfo)educationInfo andFamily:(GetPersonFamilyInfo)familyInfo;@end 我们用一张图来总结一下block的结构： block数据结构定义上图这个结构是在栈中的结构，我们来看看对应的结构体定义： 123456789101112131415struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);&#125;;struct Block_layout &#123; void *isa; int flags; int reserved; void (*invoke)(void *, ...); struct Block_descriptor *descriptor; /* Imported variables. */&#125;; 从上面代码看出，Block_layout就是对block结构体的定义： isa指针：指向表明该block类型的类。 flags：按bit位表示一些block的附加信息，比如判断block类型、判断block引用计数、判断block是否需要执行辅助函数等。 reserved：保留变量，我的理解是表示block内部的变量数。 invoke：函数指针，指向具体的block实现的函数调用地址。 descriptor：block的附加描述信息，比如保留变量数、block的大小、进行copy或dispose的辅助函数指针。 variables：因为block有闭包性，所以可以访问block外部的局部变量。这些variables就是复制到结构体中的外部局部变量或变量的地址。 block使用 作为一个局部变量 1returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;; 作为属性 1@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes); 作为一个方法参数 1- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName; 作为参数的方法调用 1[someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;]; 作为一个typedef 12typedef returnType (^TypeName)(parameterTypes);TypeName blockName = ^returnType(parameters) &#123;...&#125;; 使用block应当注意的问题 Block访问外部变量 block内部可以访问外部的变量，block默认是将其复制到其数据结构中来实现访问的。 默认情况下，block内部不能修改外面的局部变量，因为通过block进行闭包的变量是const的。 给局部变量加上__block关键字，这个局部变量就可以在block内部修改，block是复制其引用地址来实现访问的。 Block作为属性应该用copy修饰 当用weak、assign修饰block属性时，block访问外部变量，此时block的类型是栈block。保存在栈中的block，当block所在函数\方法返回\结束，该block就会被销毁。在其他方法内部调用访问该block，就会引发野指针错误EXC_BAD_ACCESS。 当用copy、strong修饰block属性时，block访问外部变量，此时block的类型是堆block。保存在堆中的block，当引用计数器为0时被销毁，该类型block是由栈类型的block从栈中复制到堆中形成的，因此可以在其他方法内部调用该block。在ARC下，strong和copy都可以用来修饰block，但是建议修饰block属性使用copy。 参考链接 How Do I Declare A Block in Objective-C? 谈Objective-C block的实现 Block的使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何用Python的filter函数求素数]]></title>
      <url>%2F2016%2F07%2F11%2Fuse-filter-method-export-prime-number-in-python%2F</url>
      <content type="text"><![CDATA[算法介绍：计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单： 首先，列出从2开始的所有自然数，构造一个序列： 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉： 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉： 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数5，然后用5把序列的5的倍数筛掉： 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 不断筛下去，就可以得到所有的素数。 python 算法 首先可以先构造一个从3开始的奇数序列： 12345def _odd_iter(): n = 1 while True: n = n + 2 yield n 注意这是一个生成器，并且是一个无限序列。为什么要构造从3开始的奇数数列，而不是上面原理中的从2开始的所有自然数数列？因为除了2的偶数数列不可能是素数。 然后定义一个筛选函数： 12def _not_divisible(n): return lambda x: x % n &gt; 0 最后，定义一个生成器，不断返回下一个素数： 1234567def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。 由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件： 123456# 打印1000以内的素数:for n in primes(): if n &lt; 1000: print(n) else: break 注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。 示例Python源码下载 扩展资料 廖雪峰Python教程–生成器:generator 廖雪峰Python教程–迭代器:Iterator 廖雪峰Python教程–匿名函数:lambda 廖雪峰Python教程–筛选函数:filter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python中列表，元组，字符串如何相互转换]]></title>
      <url>%2F2016%2F07%2F07%2FHow-to-convert-type-in-list-tuple-and-str%2F</url>
      <content type="text"><![CDATA[Python中列表，元组，字符串相互转换可以使用以下几个函数： list() tuple() join() str() 1234567891011121314s = "abcdefg"print(list(s))#['a', 'b', 'c', 'd', 'e', 'f', 'g']print(tuple(s))#('a', 'b', 'c', 'd', 'e', 'f', 'g')print(list(tuple(s)))#['a', 'b', 'c', 'd', 'e', 'f', 'g']print(tuple(list(s)))#('a', 'b', 'c', 'd', 'e', 'f', 'g')print("".join(list(s)))#abcdefgprint("".join(tuple(s)))#abcdefg]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xcode 常用插件汇总]]></title>
      <url>%2F2016%2F06%2F08%2Fxcode-plugin-part%2F</url>
      <content type="text"><![CDATA[ActivatePowerMode : ActivatePowerMode is a plugin for Xcode. This plugin will make your code powerful. Backlight-for-XCode : Highlights the current editing line in Xcode Xcode-CComment : Xcode plugin for C Style Comment(uncomment) /**/ Shortcuts cocoapods-xcode-plugin : Dependency management helper for your CocoaPods, right in Xcode DXXcodeConsoleUnicodePlugin : 转换Xcode控制台中一些不可阅读的字符，比如 \u22AD 这种 ESJsonFormat-Xcode : 将JSON格式化输出为模型的属性 FuzzyAutocompletePlugin : A Xcode 5+ plugin that adds more flexible autocompletion rather than just prefix-matching.(笔者注：最新版的Xcode默认有该功能了) HOStringSense-for-Xcode : Plugin for Xcode to make working with strings less “escaped” IndentComments : IndentComments is a plugin for Xcode. This plugin will let your comments indent. injectionforxcode : Runtime Code Injection for Objective-C &amp; Swift KSImageNamed-Xcode : Xcode plug-in that provides autocomplete for imageNamed: calls Peckham : Add #import-s from anywhere in the code. SCXcodeSwitchExpander : Xcode plugin that enables switch cases autocompletion VVDocumenter-Xcode : Xcode plug-in which helps you write documentation comment easier, for both Objective-C and Swift. XAlign : An amazing Xcode plugin to align regular code. it can align Xnything in any way you want. http://qfi.sh/XAlign/ ZLGotoSandboxPlugin : You can quickly enter the iOS simulator Xcode plugin!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抓包神器 -- Charles]]></title>
      <url>%2F2016%2F06%2F07%2Fmac-software-charles%2F</url>
      <content type="text"><![CDATA[Charles主要的功能包括： 支持SSL代理。可以截取分析SSL的请求。 支持流量控制。可以模拟慢速网络以及等待时间（latency）较长的请求。 支持AJAX调试。可以自动将json或xml数据格式化，方便查看。 支持AMF调试。可以将Flash Remoting 或 Flex Remoting信息格式化，方便查看。 支持重发网络请求，方便后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 检查HTML，CSS和RSS内容是否符合W3C标准。 官方下载地址 破解版-百度云盘地址(密码: bv4w) 如果是抓取http数据，成功安装好后设置完代理端口号（端口号随便设置，不过一般都是8888），开启代理即可抓包，如果还是不会使用可以参考下方的扩展资料1：唐巧大神以前写过的一篇文章。 https抓包附上官网说明： LEGACY SSL PROXYING Version of Charles prior to v3.10 used a single SSL Root Certificate. You can still download the legacy certificate bundle here or the certificate itself here (for installing on mobile devices). Note that these certificates will not work on Charles v3.10. If you are running Charles v3.10 or later, please go to Charles and consult the SSL Proxying submenu in the Help menu, for instructions on installing your new Charles Root Certificate. You can also check the documentation on SSL Certificates for instructions for installing your Charles Root Certificate on various devices. 简言之： 手机端操作： 如果charles是v3.10之前的版本，则SSL证书从这个地址下载： http://www.charlesproxy.com/documentation/using-charles/ssl-certificates/ 如果是v3.10或者之后的版本（包括3.10）则SSL证书相关信息详情在这个页面： http://www.charlesproxy.com/documentation/using-charles/ssl-certificates/ 电脑端操作： 在Charles的工具栏上点击设置按钮，选择Proxy Settings…切换到SSL选项卡，选中Enable SSL Proxying。（新版本的操作：Proxy -&gt; SSL Proxying Settings 切换到SSL选项卡，选中Enable SSL Proxying 即可） SSL选项卡的Locations里填写要抓包的域名和端口，点击Add按钮，在弹出的表单中Host填写域名。比如填www.google.com，Port填443 扩展资料 iOS开发工具——网络封包分析工具Charles charles官方文档 Charles 从入门到精通]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Method Swizzling]]></title>
      <url>%2F2016%2F05%2F24%2Fmethod-swizzling%2F</url>
      <content type="text"><![CDATA[Method Swizzling是改变一个selector的实际实现的技术。通过这一技术，我们可以在运行时通过修改类的分发表中selector对应的函数，来修改方法的实现。 例如，我们想跟踪在程序中每一个view controller展示给用户的次数：当然，我们可以在每个view controller的viewDidAppear中添加跟踪代码；但是这太过麻烦，需要在每个view controller中写重复的代码。创建一个子类可能是一种实现方式，但需要同时创建UIViewController, UITableViewController, UINavigationController及其它UIKit中view controller的子类，这同样会产生许多重复的代码。 幸运的是，还有另外一种方法，我们可以在类别中使用 Method Swizzling，代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // When swizzling a class method, use the following: // Class class = object_getClass((id)self); // ... // Method originalMethod = class_getClassMethod(class, originalSelector); // Method swizzledMethod = class_getClassMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@"viewWillAppear: %@", self);&#125;@end 在这里，我们通过method swizzling修改了UIViewController的@selector(viewWillAppear:)对应的函数指针，使其实现指向了我们自定义的xxx_viewWillAppear的实现。这样，当UIViewController及其子类的对象调用viewWillAppear时，都会打印一条日志信息。 上面的例子很好地展示了使用method swizzling来一个类中注入一些我们新的操作。当然，还有许多场景可以使用method swizzling，在此不多举例。在此我们说说使用method swizzling需要注意的一些问题： Swizzling应该总是在+load中执行在Objective-C中，运行时会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。由于method swizzling会影响到类的全局状态，因此要尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下，+initialize在其执行时不提供这种保证—事实上，如果在应用中没为给这个类发送消息，则它可能永远不会被调用。 Swizzling应该总是在dispatch_once中执行与上面相同，因为swizzling会改变全局状态，所以我们需要在运行时采取一些预防措施。原子性就是这样一种措施，它确保代码只被执行一次，不管有多少个线程。GCD的dispatch_once可以确保这种行为，我们应该将其作为method swizzling的最佳实践。 选择器、方法与实现在Objective-C中，选择器(selector)、方法(method)和实现(implementation)是运行时中一个特殊点，虽然在一般情况下，这些术语更多的是用在消息发送的过程描述中。 以下是Objective-C Runtime Reference中的对这几个术语一些描述： Selector(typedef struct objc_selector *SEL)：用于在运行时中表示一个方法的名称。一个方法选择器是一个C字符串，它是在Objective-C运行时被注册的。选择器由编译器生成，并且在类被加载时由运行时自动做映射操作。 Method(typedef struct objc_method *Method)：在类定义中表示方法的类型 Implementation(typedef id (*IMP)(id, SEL, …))：这是一个指针类型，指向方法实现函数的开始位置。这个函数使用为当前CPU架构实现的标准C调用规范。每一个参数是指向对象自身的指针(self)，第二个参数是方法选择器。然后是方法的实际参数。 理解这几个术语之间的关系最好的方式是：一个类维护一个运行时可接收的消息分发表；分发表中的每个入口是一个方法(Method)，其中key是一个特定名称，即选择器(SEL)，其对应一个实现(IMP)，即指向底层C函数的指针。 为了swizzle一个方法，我们可以在分发表中将一个方法的现有的选择器映射到不同的实现，而将该选择器对应的原始实现关联到一个新的选择器中。 调用_cmd我们回过头来看看前面新的方法的实现代码：12345- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@"viewWillAppear: %@", NSStringFromClass([self class]));&#125; 咋看上去是会导致无限循环的。但令人惊奇的是，并没有出现这种情况。在swizzling的过程中，方法中的[self xxx_viewWillAppear:animated]已经被重新指定到UIViewController类的-viewWillAppear:中。在这种情况下，不会产生无限循环。不过如果我们调用的是[self viewWillAppear:animated]，则会产生无限循环，因为这个方法的实现在运行时已经被重新指定为xxx_viewWillAppear:了。 注意事项Swizzling通常被称作是一种黑魔法，容易产生不可预知的行为和无法预见的后果。虽然它不是最安全的，但如果遵从以下几点预防措施的话，还是比较安全的： 总是调用方法的原始实现(除非有更好的理由不这么做)：API提供了一个输入与输出约定，但其内部实现是一个黑盒。Swizzle一个方法而不调用原始实现可能会打破私有状态底层操作，从而影响到程序的其它部分。 避免冲突：给自定义的分类方法加前缀，从而使其与所依赖的代码库不会存在命名冲突。 明白是怎么回事：简单地拷贝粘贴swizzle代码而不理解它是如何工作的，不仅危险，而且会浪费学习Objective-C运行时的机会。阅读Objective-C Runtime Reference和查看头文件以了解事件是如何发生的。 小心操作：无论我们对Foundation, UIKit或其它内建框架执行Swizzle操作抱有多大信心，需要知道在下一版本中许多事可能会不一样。 扩展阅读 原文地址：Method Swizzling Objective-C Runtime Reference 南峰子的技术博客：Objective-C Runtime运行时系列教程 Objective-C的动态特性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 常用数学函数]]></title>
      <url>%2F2016%2F05%2F09%2Fcommon-mathematical-functions%2F</url>
      <content type="text"><![CDATA[三角函数 double sin (double);正弦 double cos (double);余弦 double tan (double);正切 反三角函数 double asin (double); 结果介于[-PI/2, PI/2] double acos (double); 结果介于[0, PI] double atan (double); 反正切(主值), 结果介于[-PI/2, PI/2] double atan2 (double, double); 反正切(整圆值), 结果介于[-PI, PI] 双曲三角函数 double sinh (double); double cosh (double); double tanh (double); 指数与对数 double exp (double);求取自然数e的幂 double sqrt (double);开平方 double log (double); 以e为底的对数 double log10 (double);以10为底的对数 double pow(double x, double y）;计算以x为底数的y次幂 float powf(float x, float y); 功能与pow一致，只是输入与输出皆为浮点数 取整 double ceil (double); 取上整 double floor (double); 取下整 绝对值 double fabs (double);求绝对值 double cabs(struct complex znum) ;求复数的绝对值 标准化浮点数 double frexp (double f, int p); 标准化浮点数, f = x 2^p, 已知f求x, p ( x介于[0.5, 1] ) double ldexp (double x, int p); 与frexp相反, 已知x, p求f 取整与取余 double modf (double, double*); 将参数的整数部分通过指针回传, 返回小数部分 double fmod (double, double); 返回两参数相除的余数 其他 double hypot(double x, double y);已知直角三角形两个直角边长度，求斜边长度 double ldexp(double x, int exponent);计算x(2的exponent次幂) double poly(double x, int degree, double coeffs [] );计算多项式 nt matherr(struct exception e);数学错误计算处理程序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何创建一个私有pod库]]></title>
      <url>%2F2016%2F04%2F17%2FHow-to-create-private-pod%2F</url>
      <content type="text"><![CDATA[本文写的不是很详细，只是记录自己操作的一个大致过程。更加详细的操作，大家不妨参考使用Cocoapods创建私有podspec，我也是按照上面一步一步操作的，只不过个人觉得那个排版看起来真的不太友好。如果英文不错的话，其实我更建议大家看看下面的英文参考链接。 准备工作首先创建两个Git仓库，一个用来存放私有Spec Repo，另一个则存放我们私有的类库。因为Github上面私有库是要收费的，所以我选择了Coding 创建私有Spec Repo 创建本地私有Spec Repo，在终端输入下面命令即可 12# pod repo add [Private Repo Name] [Coding HTTPS clone URL]$ pod repo add DQBSpecs https://git.coding.net/qingbo/DQBSpecs.git 输完命令运行后，就在~/.cocoapods/repos/目录下自动生成了一个名为DQBSpecs的本地私有Spec Repo. 创建Pod项目工程文件如果是有现有的组件项目，并且在Git的版本管理下，那么这一步就算完成了，可以直接进行下一步了。 如果你的组件还在你冗余庞大的项目中，需要拆分出来或者需要自己从零开始创建一个组件库，那么建议你使用Cocoapods提供的一个工具将这一步与下一步结合起来做。 现在来说一下这个工具，相关的文档介绍是Using Pod Lib Create，就拿我创建的DQBLibrary为例子具体讲一下这里是如何操作的。 首先cd到要创建项目的目录下，然后执行 1$ pod lib create DQBLibrary 接下来会出现几个选项，输入你所期望的就OK啦，附上我的选项截图： 创建podspec文件如果现在有了现成的项目（是指不是通过pod lib create XXXX来创建的项目，如果是通过pod lib create命令创建的项目默认就会生成一个podspec文件）那么就需要给这个项目创建一个podspec文件，创建它需要执行Cocoapods的另外一个命令，官方文档在这里 1$ pod spec create YourLibrary git@xxxxx/YourLibrary.git 执行完之后，就创建了一个podspec文件，它其中会包含很多内容，可以按照需求进行编辑，没用的删掉。 1234567891011121314151617181920212223242526272829 Pod::Spec.new do |s| s.name = "DQBLibrary" #名称 s.version = "0.1.0" #版本号 s.summary = "Just Testing." #简短介绍，下面是详细介绍 s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don't worry about the indent, we strip it! DESC s.homepage = "https://coding.net/u/qingbo/p/DQBLibrary" #主页,这里要填写可以访问到的地址，不然验证不通过 # s.screenshots = "www.example.com/screenshots_1", "www.example.com/screenshots_2" #截图 s.license = 'MIT' #开源协议 s.author = &#123; "DQB" =&gt; "dqb1690@163.com" &#125; #作者信息 s.source = &#123; :git =&gt; "https://git.coding.net/qingbo/DQBLibrary.git", :tag =&gt; s.version.to_s &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # s.social_media_url = 'https://twitter.com/&lt;twitter_username&gt;' #多媒体介绍地址 s.platform = :ios, '7.0' #支持的平台及版本 s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC s.source_files = 'DQBLibrary/Classes/**/*' #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置 s.resource_bundles = &#123; 'DQBLibrary' =&gt; ['DQBLibrary/Assets/*.png'] &#125; #资源文件地址 # s.public_header_files = 'Pod/Classes/**/*.h' #公开头文件地址 # s.frameworks = 'UIKit', 'MapKit' #所需的framework，多个用逗号隔开 s.dependency 'AFNetworking', '~&gt; 2.3' #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependencyend 编辑完成之后使用验证命令验证一下 1$ pod lib lint 向Spec Repo提交podspec向Spec Repo提交podspec需要完成两点一个是podspec必须通过验证无误，在一个就是删掉无用的注释（这个不是必须的，为了规范还是删掉吧）。 向我们的私有Spec Repo提交podspec只需要一个命令 1$ pod repo push DQBSpecs DQBLibrary.podspec 完成之后这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/DQBSpecs目录下查看 再去看我们的Spec Repo远端仓库，也有了一次提交，这个podspec也已经被Push上去了。 至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了 这里说的是添加到私有的Repo，如果要添加到Cocoapods的官方库了，可以使用trunk工具，具体可以查看官方文档。 使用制作好的Pod在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了,我们需要在podfile文件顶端中多定义一个source，该source地址是我们私有git地址，示例代码如下： 1234source 'https://github.com/CocoaPods/Specs.git' # 官方库source 'https://git.coding.net/qingbo/DQBLibrary.git' # 私有库pod 'DQBLibrary', :git =&gt; 'git@git.coding.net:qingbo/DQBLibrary.git', :tag =&gt; "0.1.1" 更新podspec文件首先修改工程里的podspec文件，然后pod install，将变动全部提交至对应的git服务器（工程文件对应的git地址，并非Spec文件对应的git地址），并添加一个新的tag值。然后pod lib lint先验证一下，再进行下面更新操作： 1$ pod repo push DQBSpecs PodTestLibrary.podspec #pod私有库 前面是本地Repo名字 后面是podspec名字 更新成功后，你可以在~/.cocoapods/repos/的私有库目录下查看新增了一个文件夹名为tag，该目录下生成了对应tag的podspec文件。 参考资料 使用Cocoapods创建私有podspec Private Pods Creating a Private CocoaPod Developing Private In-House Libraries with CocoaPods]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ReactiveCocoa基础知识]]></title>
      <url>%2F2016%2F04%2F10%2FReactiveCocoa-Basic-Use%2F</url>
      <content type="text"><![CDATA[什么是ReactiveCocoa ？ReactiveCocoa（其简称为RAC）是由Github开源的一个应用于iOS和OS X开发的新框架。RAC具有函数式编程和响应式编程的特性。它主要吸取了.Net的 Reactive Extensions的设计和实现。 ReactiveCocoa编程风格：函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。 响应式编程（Reactive Programming）：关注于数据流和变化传播。 所以，你可能听说过ReactiveCocoa被描述为函数响应式编程（FRP）框架。编程范式是个很范的概念。 如何使用ReactiveCocoa ？教程比较好，建议边看边敲代码 ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2 ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2 对应的中文翻译版： ReactiveCocoa入门教程——第一部分 ReactiveCocoa入门教程——第二部分 扩展链接 细说ReactiveCocoa的冷信号与热信号(一) 细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号 细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH 相关知识]]></title>
      <url>%2F2016%2F03%2F15%2FSSH%2F</url>
      <content type="text"><![CDATA[SSH登陆的原理1. 什么是SSHSSH（安全外壳协议）为 Secure Shell 的缩写，一种网络协议，用于计算机之间的加密通信。 2. 公钥Public Key与私钥Private KeySSH Key SSH需要生成公钥Public Key和私钥Private Key, 常用的是使用RSA算法生成id_rsa.pub和id_rsa。 公钥Public Key(id_rsa.pub)是可以暴露在网络传输上的，是不安全的。而私钥Private Key(id_rsa)是不可暴露的，只能存在客户端本机上。所以公钥Public Key(id_rsa.pub)的权限是644，而私钥Private Key(id_rsa)的权限只能是600。如果权限不对，SSH会认为公钥Public Key(id_rsa.pub)和私钥Private Key(id_rsa)是不可靠的，就无法正常使用SSH登陆了。 同时在服务端会有一个~/.ssh/authorized_keys文件，里面存放了多个客户端的公钥Public Key(id_rsa.pub)，就表示拥有这些Public Key的客户端就可以通过SSH登陆服务端。 3. SSH公钥登录过程客户端发出公钥登陆的请求(ssh user@host)服务端返回一段随机字符串客户端用私钥Private Key(id_rsa)加密这个字符串，再发送回服务端服务端用~/.ssh/authorized_keys里面存储的公钥Public Key去解密收到的字符串。如果成功，就表明这个客户端是可信的，客户端就可以成功登陆 由此可见，只要多台电脑上的的公钥Public Key(id_rsa.pub)和私钥Private Key(id_rsa)是一样的，对于服务端来说着其实就是同一个客户端。所以可以通过复制公钥Public Key(id_rsa.pub)和私钥Private Key(id_rsa)到多台电脑来实现共享登陆。 如何生成SSH key 在生成SSH key之前，避免可能把之前的key覆盖掉，首先可以检查以前的key是否存在，有则可以跳过第二步。（如何查看？直接在终端输入“ls ~/.ssh”查看里面是否有id_rsa和id_rsa.pub 文件） 生成SSH key很容易，只需要提供一个邮箱账号即可，切换到~/.ssh文件目录下，在终端输入： 1$ ssh-keygen -t rsa -C "your_email@example.com" 将生成的id_rsa.pub文件内容复制到相应的网站里（比如公司服务器，Github，Coding等），提供一个很方便的拷贝语句 1$ pbcopy &lt; ~/.ssh/id_rsa.pub 测试SSH连接$ ssh -T git@github.com 如果展示下诉信息，则说明SSH连接成功 12Hi username! You've successfully authenticated, but GitHub does notprovide shell access. 扩展阅读 如何生成SSH key Connecting to GitHub with SSH]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【转】一个大神开发者的使命感究竟应该是什么]]></title>
      <url>%2F2016%2F03%2F08%2FThe-Role-of-a-Senior-Developer%2F</url>
      <content type="text"><![CDATA[工作了五年的工程师，算不算高级开发者？归类开发者不是简单地看工作年限，因为经验这种东西千金难换但又一文不值。 我们现在工作的行业很奇怪。明明每年都有新的从业人员涌入人才市场，但企业依旧诉苦自己迫切需要大量的开发。这种问题存在已久，而且已经越发严峻。 开发者这个行业非常年轻，也面临着很严重的人才短缺问题。大部分的软件开发项目无疾而终，原因是后期开支过于庞大。那些行业里的大佬是怎么建议我们的，他们说「世界上永远存在解决问题的办法，但我们还是会遇到各种难题。因为除非我们真正去尝试解决，否则永远不知道哪种方法奏效。」 认识一个现实吧，当你从事开发工作三年以上，就可以称呼自己为「高级开发者」。但实际上，有些人只是在这个位置上混三年，而他们只是虚有其表，水平严重不符合职位。 这确实是我对同行的评语。 首先，根据知识和经验把人分为初级开发者、中级开发者，和高级开发者，这是非常一刀切地分类。有些人可能只是在一个位置上混了十年，然而他的成长甚至没有另一个人一年所学到和经验多。 开发者的高速成长期：身为一个程序员，我们生活在一个 IT 系统越发复杂且多变化的时代。有时候执行一个简单的开源项目，都需要精准定义并耗费大量时间专注任务。尤其是当你身为一个新晋程序员，或者对手下的数据库还很陌生的时候。 菜鸟程序员很难当。你可能刚从一个还不错的大学毕业，你觉得你已经掌握了基本的常识。但突然间，你在工作上面临的是另一套崭新的知识。在很长时间内，你都对自己所要做的工作没有任何头绪。而对于上司提出的要求，你似乎只能妥协，而且没办法作出有效质疑。 在这个阶段，你必须要做的是专注。而且尽可能地放开心胸，去努力学习。初级开发者在工作之初，需要大量的练习，指导、监管，以及需要一个能帮助他们的老师。缺乏以上的任何条件，初级开发者都很难很难迈过这个初学者门槛。 我最近遇到一个家伙，他已经有十年的软件构造经验，但是我很遗憾地发现，他的真实水平依旧只是初级开发者。你可以说这个阶段，是战略上的积累状态，但就是要学习加积累，积累再学习，缺一不可。 初级开发者必须要专注代码本身，在这个阶段，不要分心想任何其他乱七八糟的事情。在开发一个项目时，如果身为程序员想的是「我想让自己的代码在别人眼里看起来漂漂亮亮的」，而不是「我做的东西应该以用户感受第一」，那么他本身就是一个初级开发。 一个好的开发者可以出色地完成任务，而且不仅如此，他们能以较短时间出色完成任何，后期也会维护好。 中级开发者的瓶颈期间当一个开发者脱离菜鸟阶段成长为中级开发者时，他们能够在项目失败时反省整个过程（通常，他们会看自己所做工作部分）。而且会意识到，比起匆匆忙忙埋头苦干完成任务，应该在项目最初就建立起一些规矩。甚至于如果最开始有人指正他们，整个项目就能在最初避免走向失败。 而中级开发者还会体验另一个独特心理过程，那就是当他们回首一年前的工作。发现尽管当时认为「哎呦，自己做的还不错」，但现在会发现「这都什么玩意」啊。 一个中级开发者是有能力通过以往经验、文本资料、项目团队讨论等方式，摸索出「正确方法」做事的人。在这个阶段，学习构建软件的理论比学习构建代码更重要（后者应该在学校就掌握了）。 另一方面，中级开发者假如自作主张起来，造成的危害比初级开发者更大。初级开发者只会堆砌算法，一个好的中级开发者努力方向是「模式设计」和「范畴驱动设计」。这些技能是他们搭造 OO 系统的必备过程，学习完这些理论知识如果灵活运用，可以让他们更好地构造项目。但如果僵硬使用，也会危害整个项目。 有的时候，让一名中级开发者搭造系统，他耗费的时间可能比初级开发者更长，而且更糟的情况是他可能带整个团队走向迷途。很可悲的是，很多项目开发之所以走向失败，因为领队者自己只是一个中级开发者，他们缺乏和高级开发者工作的珍贵经验。团队领导自己，而且团队里其他人都没有意识到这点。 中级开发者很清楚自己在团队中起到的角色，能认识到他们给团队工作带来的价值。一个好的中级开发者知道代码是用来解决问题的，而不是用来终结问题的。然而，中级开发者总容易陷入一种认知上的金字塔，那就是他们会遵循一些「正确的方式」去解决问题。 一个好的中级开发者需要少而精的监管。他们在代码构造方向非常可靠，而且会在讨论设计的过程中发挥重要作用。中级开发者是团队中的「发动机」。但是，如果进一步的指导和更高级别的监管仍然是必不可少。 高级，甚至是大神开发者需要满足的条件一个高级开发者，不夸张地说，他能记住自己每次的错误。他们甚至能在设计或者编写代码的时候，就能预见到很多失败。他们会对错误进行非常敏锐地反馈，用一种诚实的方法去评估自己的成功和失败。身为高级开发者，他会更倾向于热爱复杂问题，但会痴迷于简洁地解决它。 高级开发者不会给其他开发者划分等级。与之相比，他更多的是懂得。因为懂得，所以理解每个人在每个阶段都有长处和短处。而他们也比别人更了解自己的长处和短处，力求把自己的优势最大化。 一个高级开发者会懂得，所有理论基础都有背景支持。他们不会执着于「对的方式」去搭造软件，而是把理论灵活运用于实际，理论可以变通用于为客户、团队和组织需要服务的工具。 高级开发者会在项目过程中，设身处地了解客户想要什么样的工作结果，以及他们的喜好。毕竟这些东西，比开发者个人的偏好和成功更重要。他们永远不会说「那不是我的工作」，也永远不会推搡任务和责任。 资深开发者会懂得一件事，那就是他们的工作是为了客户提供解决方案，而不是埋头写代码。而一位资深开发者永远会把自己团队能给顾客带来多少价值，放在考核标准。而不是把自己的努力和客户需求放在对等的 PK 赛场里。 诚然，因为这是一份工作，所以中间的过程总会非常枯燥和无聊。但资深开发者会退一步，思考怎么能解决和打破这些无聊的问题。他们会评估本源问题，直接解决它。或者他们会把枯燥情绪放在旁边，修复日常必须要面对的问题。 资深开发者也会懂得团队工作的高效。没有人能自己做一切工作，他们会致力于提升自己团队的效率。他们把提高团队效率所做的行为，视为提高自己软实力的一部分。 资深开发者懂得，领导力不仅仅只是权力，也不仅仅只是控制力。权力不是交通棒，而是一种服务意识。 如果你的团队中缺乏高级开发者，那这个项目基本都无一例外走向失败。拥有中级开发者能让你做事情非常快，但是在工作中你会发现，项目不仅仅只是搭造和维护程序。最终你只能关闭网站，或者用比预期中更高昂的价格维护它。只有高级开发者能选择技术和网站，而不是任由他们来伤害你。 很多需求很简单，但大多数简单需求后面，隐藏更复杂的需求。 而现实情况是，我自己很厌倦以工作时限来分类开发者。是的，工作经验能告诉你很多事情，但通常提供的都是无意义的信息。甚至于这些信息，也必须要结合很多背景来判断。 更重要的是，我们行业里需要新鲜的血液，需要招收那些刚从大学毕业充满激情的年轻人。而即使给程序员划分种类，也不可仅仅只看工作经验。实际上我们招收程序员前，应该先思考团队都需要那些人才。毕竟，我们招收的人才是为团队服务。当你招聘到错误的人选，不过是给团队和项目帮倒忙。 本文来源：mattbriggs 译文创见首发 由TECH2IPO/创见 假冒爱丽丝编译]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[有关NSAssert相关知识点]]></title>
      <url>%2F2016%2F03%2F03%2FNSAssert%2F</url>
      <content type="text"><![CDATA[苹果官方文档写的比较清楚： NSAssert Generates an assertion if a given condition is false. Declaration 1#define NSAssert(condition, desc, ...) Parameters condition：An expression that evaluates to YES or NOdesc： An NSString object that contains a printf-style string containing an error message describing the failure condition and placeholders for the arguments …：The arguments displayed in the desc string Discussion The NSAssert macro evaluates the condition and serves as a front end to the assertion handler. Each thread has its own assertion handler, which is an object of class NSAssertionHandler. When invoked, an assertion handler prints an error message that includes the method and class names (or the function name). It then raises an NSInternalInconsistencyException exception. If condition evaluates to NO, the macro invokes handleFailureInMethod:object:file:lineNumber:description: on the assertion handler for the current thread, passing desc as the description string. This macro should be used only within Objective-C methods. Assertions are disabled if the preprocessor macro NS_BLOCK_ASSERTIONS is defined. 而且在NSException.h 文件中，我们可以清楚的看到 NSAssert 的宏定义: 123456789101112#define NSAssert(condition, desc, ...) \ do &#123; \__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \if (!(condition)) &#123; \ NSString *__assert_file__ = [NSString stringWithUTF8String:__FILE__]; \ __assert_file__ = __assert_file__ ? __assert_file__ : @"&lt;Unknown File&gt;"; \ [[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \ object:self file:__assert_file__ \ lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \&#125; \ __PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \ &#125; while(0) 苹果文档提供了一种禁用Assertions的方法，在实践的过程中我又发现了另外一个禁用NSAssert的方法，详情如下： 苹果文档：“Build Settings” -&gt; “preprocessor macro” -&gt; 添加“NS_BLOCK_ASSERTIONS” 则禁用了Assertions 另一种方式：“Build Settings” -&gt; “Other C Flags” -&gt; 添加“-DNS_BLOCK_ASSERTIONS”即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何禁用iOS系统方法？]]></title>
      <url>%2F2016%2F02%2F24%2FHow-to-disable-system-methods%2F</url>
      <content type="text"><![CDATA[出于某种需求，我需要禁用iOS系统提供的某些系统方法。可以采用如下的方法： 123+(instancetype) alloc __attribute__((unavailable("call other method instead")));-(instancetype) init __attribute__((unavailable("call other method instead")));+(instancetype) new __attribute__((unavailable("call other method instead"))); 一旦我们在程序中使用到了alloc、init、new等相关方法的时候，就会出现如下错误提示：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何给iOS应用添加原生的二维码扫描功能]]></title>
      <url>%2F2016%2F01%2F23%2Fhow-add-qr-scan%2F</url>
      <content type="text"><![CDATA[之前总觉得二维码扫描很高大上，其实apple工程师早就为我们提供了便捷的方法。二维码扫描第三方的库也挺多的，不过效率高的当属系统提供的扫描方法。 二维码扫描主要用到了以下几个类： AVCaptureDevice AVCaptureDeviceInput AVCaptureMetadataOutput AVCaptureSession AVCaptureVideoPreviewLayer 它们之间的关系看这篇文章 扫描的核心代码如下（最后附上完整Demo） 1234567891011121314151617181920212223242526272829303132333435363738//获取摄像设备AVCaptureDevice * device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];if (!device) return;//创建输入流AVCaptureDeviceInput * input = [AVCaptureDeviceInput deviceInputWithDevice:device error:nil];if (!input) return;//创建输出流AVCaptureMetadataOutput * output = [[AVCaptureMetadataOutput alloc]init];if (!output) return;output.rectOfInterest = CGRectMake(0.1, 0, 0.9, 1);//设置代理 在主线程里刷新[output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()];//初始化链接对象_session = [[AVCaptureSession alloc]init];//高质量采集率[_session setSessionPreset:AVCaptureSessionPresetHigh];if ([_session canAddInput:input]) &#123; [_session addInput:input];&#125;else&#123; return;&#125;if ([_session canAddOutput:output]) &#123; [_session addOutput:output];&#125;else&#123; return;&#125;//设置扫码支持的编码格式(如下设置条形码和二维码兼容)output.metadataObjectTypes=@[AVMetadataObjectTypeQRCode,AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode128Code];AVCaptureVideoPreviewLayer * layer = [AVCaptureVideoPreviewLayer layerWithSession:_session];layer.videoGravity = AVLayerVideoGravityResizeAspectFill;layer.frame = self.view.layer.bounds;[self.view.layer insertSublayer:layer atIndex:0];//开始捕获[_session startRunning]; Demo地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS开发常用的第三方资源汇总]]></title>
      <url>%2F2016%2F01%2F21%2FiOS%20developers-of-third-party-resources-summary%2F</url>
      <content type="text"><![CDATA[一：第三方插件1:基于响应式编程思想的oc 地址：https://github.com/ReactiveCocoa/ReactiveCocoa 2：hud提示框 地址：https://github.com/jdg/MBProgressHUD 3：XML/HTML解析 地址：https://github.com/topfunky/hpple 4：有文字输入时，能根据键盘是否弹出来调整自身显示内容的位置 地址：https://github.com/michaeltyson/TPKeyboardAvoiding 5：状态栏提示框 地址：https://github.com/jaydee3/JDStatusBarNotification 6：block工具包。将很多需要用delegate实现的方法整合成了block的形式 地址：https://github.com/zwaldowski/BlocksKit 7：图片加载 地址：https://github.com/rs/SDWebImage 8：正则表达式 地址：https://github.com/wezm/RegexKitLite 9：Masonry代码布局 地址：https://github.com/SnapKit/Masonry 10：弹出窗 地址：https://github.com/sberrevoets/SDCAlertView 11:Button的样式 地址：https://github.com/mattlawer/BButton 12：验证网络连接状态 地址：https://github.com/tonymillion/Reachability 13：自动计算表格行高 地址：https://github.com/forkingdog/UITableView-FDTemplateLayoutCell 14：动画效果的启动页 地址：https://github.com/IFTTT/JazzHands 15：iOS快速简单集成国内三大平台分享 地址：https://github.com/xumeng/XMShareModule 16：五项能力值展示的五边形 地址：https://github.com/dsxNiubility/SXFiveScoreShow 17：自动识别网址号码邮箱和表情的label 地址：https://github.com/molon/MLEmojiLabel 18：IM对话功能的封装 地址：https://github.com/ZhipingYang/UUChatTableView 19：字典转模型框架 地址：https://github.com/CoderMJLee/MJExtension 20：下拉上拉刷数据 地址：https://github.com/CoderMJLee/MJRefresh 21：表格行左右划动菜单 地址：https://github.com/MortimerGoro/MGSwipeTableCell 22:图文混搭 地址:https://github.com/zhouande/TLAttributedLabel 23:可以简单展示在UINavigationBar下方，类似Music app的播放列表视图，弹出菜单视图 地址：https://github.com/DrummerB/BFNavigationBarDrawer 24：比如筛选、模糊、优化、蒙版、调整大小、旋转以及保存等等。同时还提供了一个UIImageView子类从URL异步加载图片，并在下载完毕时展示图片。 地址：https://github.com/Nyx0uf/NYXImagesKit 25：底部TabBar 地址：https://github.com/robbdimitrov/RDVTabBarController 26:表情面版 地址：https://github.com/ayushgoel/AGEmojiKeyboard 27:记录框架 地址：https://github.com/CocoaLumberjack/CocoaLumberjack 28：IOS与javascript交互 地址：https://github.com/marcuswestin/WebViewJavascriptBridge 29：图表统计展示 地址：https://github.com/kevinzhow/PNChart 30:appStore评分 地址：https://github.com/arashpayan/appirater 31：iOS-Categories 扩展类大全 地址：https://github.com/shaojiankui/IOS-Categories 32：扫描二维码，仿微信效果，带有扫描条 地址：https://github.com/JxbSir/JxbScanQR 33:动效弹出视图(弹出窗里面为文字，可以定义弹出的方向，及显示的时间)–AMPopTip 地址：https://github.com/andreamazz/AMPopTip 34:基于Masonry自动计算行高扩展 地址：https://github.com/632840804/HYBMasonryAutoCellHeight 35:模仿新浪微博弹出菜单 地址：https://github.com/wwdc14/HyPopMenuView 36:搜索历史标签 地址：https://github.com/zhiwupei/SearchHistory 37：快速集成新手引导的类库 地址：https://github.com/StrongX/XSportLight 38：设置页面的封装 地址：https://github.com/renzifeng/ZFSetting 39：带箭头的弹出视图插件 地址：https://github.com/xiekw2010/DXPopover 40：下拉菜单插件 地址：https://github.com/dopcn/DOPDropDownMenu/ 41：表格空白提示插件 地址：https://github.com/dzenbot/DZNEmptyDataSet 42:给任意UIView视图四条边框加上阴影，可以自定义阴影的颜色、粗细程度、透明程度以及位置（上下左右边框） 地址：https://github.com/Seitk/UIView-Shadow-Maker 43:不错的日期时间插件 地址：https://github.com/CoderXL/UUDatePicker 44:底部弹出选择 地址：https://github.com/skywinder/ActionSheetPicker-3.0 45:比较不错的引导页面插件 地址：https://github.com/ealeksandrov/EAIntroView 46:两个APP跳转的插件 地址：https://github.com/usebutton/DeepLinkKit 47:本地存取NSUserDefaults插件 地址：https://github.com/gangverk/GVUserDefaults 48:NSArray 和 NSDictionary关于LINQ的操作方式，封装一些常用的操作 地址：https://github.com/ColinEberhardt/LinqToObjectiveC 49:可以监控网络请求的内容 地址：https://github.com/coderyi/NetworkEye 50：时间帮助插件，可以快速获取时间，比较，增加等操作 地址：https://github.com/MatthewYork/DateTools 51: 不错的链式动作 地址：https://github.com/jhurray/JHChainableAnimations 52:弹出层视图，背景效果（可以自定义视图的内容） 地址：https://github.com/HJaycee/JCAlertView 53:圆形进度条的显示，中间可显示值 地址：https://github.com/mdinacci/MDRadialProgress 54:很帅的数据加载动画（可以用于数据列表加载的展现） 地址：https://github.com/NghiaTranUIT/FeSpinner 55:一个开源的AFnetworking上层的封装（猿题库等运用） 地址：https://github.com/yuantiku/YTKNetwork 56:CBStoreHouseRefreshControl：一个效果很酷炫的下拉刷新控件 地址：https://github.com/coolbeet/CBStoreHouseRefreshControl 57:AFNetworking-RACExtensions:针对ReactiveCocoa的AF封装 地址：https://github.com/CodaFi/AFNetworking-RACExtensions 58:模糊效果（毛玻璃） 地址：https://github.com/nicklockwood/FXBlurView 59:RxWebViewController：实现类似微信的 webView 导航效果，包括进度条，左滑返回上个网页或者直接关闭，就像 UINavigationController 地址：https://github.com/Roxasora/RxWebViewController 二：源代码实例1:Coding.net客户端 地址：https://coding.net/u/coding/p/Coding-iOS/git 2:高仿美团iOS版 地址：https://github.com/lookingstars/meituan 3:模仿网易新闻做的精仿网易新闻 地址：https://github.com/dsxNiubility/SXNews 4:支付宝高仿版 地址：https://github.com/gsdios/GSD_ZHIFUBAO 5:高仿百度传课iOS版 地址：https://github.com/lookingstars/chuanke 6：模仿一元云购 地址：https://github.com/JxbSir/YiYuanYunGou 7：wordpress源代码 地址：https://github.com/wordpress-mobile/WordPress-iOS 8：v2ex源代码（文章类型，若报SVProgressHUD错，则把Podfile中的SVProgressHUD移除） 地址：https://github.com/singro/v2ex 9:PHPHub客户端(IOS8.0以上) 地址：https://github.com/Aufree/phphub-ios 10:快速搭建项目源代码 地址：https://github.com/wujunyang/MobileProject 三：辅助软件1：XCODE文档注解插件VVDocumenter 地址：https://github.com/onevcat/VVDocumenter-Xcode 2：将JSON格式化输出为模型的属性 地址：https://github.com/EnjoySR/ESJsonFormat-Xcode 3：图片提示插件 地址：https://github.com/ksuther/KSImageNamed-Xcode 4：图片转换插件 地址：https://github.com/rickytan/RTImageAssets 5：转换 Xcode 控制台中一些不可阅读的字符 地址：https://github.com/dhcdht/DXXcodeConsoleUnicodePlugin 6：代码补全支持模糊查询 https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin 7: 代码注释（command + ‘/‘）缩进【强迫症必备】 https://github.com/poboke/IndentComments 说明该文章基于CocoaChina上的一篇文章，我在此基础上补充了个人觉得还不错的插件。此文章后续会持续更新的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Adblock Plus 浏览器插件]]></title>
      <url>%2F2016%2F01%2F20%2FAdblock-Plus%2F</url>
      <content type="text"><![CDATA[Adblock Plus is the most popular adblocker available for Firefox, Chrome, Opera, Safari, Android and Internet Explorer. Adblock Plus 可让您屏蔽烦人的广告、跟踪、恶意软件及其他您不想在浏览器中看到的东西。 Adblock Plus 是 Wladimir Palant 在2006年创建的一个开源项目。 最近使用chrome的时候总是弹出烦人的网页，所以才想到Adblock Plus，这里就是如何撰写过滤规则的官方教程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CocoaPods协同开发问题]]></title>
      <url>%2F2016%2F01%2F04%2FCocoaPods-Collaborative-Development%2F</url>
      <content type="text"><![CDATA[提出问题今天临时想在podfile 里面新增一个第三方类库，按照正常方式添加后，敲入命令pod install 后，成功引进类库。但是编译的时候始终报错：Pods-XXXX(工程名，后同)-frameworks.sh: No such file or directory，通过比对文件发现，在Pods -&gt;Targets Support Files -&gt; Pods-XXXX 下果然没有该文件。 分析问题由于同事已经使用了最新版本的CocoaPods来添加类库，在本地默认生成了Pods-XXXX-frameworks.sh 文件并且已经提交至Git服务器了，而我用低版本的CocoaPods来添加类库，本地并不会生成该文件。 解决问题升级CocoaPods到最新版，再Pod install一下就好啦～，由此得出的结论：同一个公司的人如果都需要进行pod install 操作的话，最好要确保每个人使用的cocoaPods的版本号一致，避免会出现一些莫名其妙的问题。 CocoaPods如何升级目前支持增量更新. 下面一行命令就OK了 1sudo gem install cocoapods 该命令就直接将最新的cocoaPods重新安装了（当然也就升级了，不过要确保gem是最新的，有没有升级成功最后把cocoaPods的版本号打印出来就知道啦），查看当前版本的cocoaPods可以用命令pod --version，如果这样升级失败了，不妨先更新gem（国内有可能需要切换源，我是没有切换的），具体方法如下： 12345678$ sudo gem update --system // 先更新gem，国内需要切换源$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l\*\*\* CURRENT SOURCES \*\*\*https://ruby.taobao.org/$ sudo gem install cocoapods // 安装cocoapods$ pod setup Podfile.lock当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。 参考链接 CocoaPods官方文档（可能需要翻墙） CocoaPods详解之—-进阶篇 CocoaPods版本升级 CocoaPods 1.0 Migration Guide]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS中崩溃类型汇总]]></title>
      <url>%2F2015%2F09%2F28%2FiOS-crash-types%2F</url>
      <content type="text"><![CDATA[在这里了解一下XCode用来表示各种崩溃类型的术语，补充一些这方面的各知识。崩溃通常是指操作系统向正在运行的程序发送的信号，所以我们在查看崩溃日志时，常常看到如下错误摘要：Application received signal SIGSEGV。一般来说，常见的崩溃类型有以下几种： EXC_BAD_ACCESS在访问一个已经释放的对象或向它发送消息时，EXC_BAD_ACCESS就会出现。造成EXC_BAD_ACCESS最常见的原因是，在初始化方法中初始化变量时用错了所有权修饰符，这会导致对象过早地被释放。举个例子，在viewDidLoad方法中为UIViewController创建了一个包含元素的NSArray，却将该数组的所有权修饰符设成了assign而不是strong。现在在viewWillAppear中，若要访问已经释放掉的对象时，就会得到名为EXC_BAD_ACCESS的崩溃。 这个崩溃发生时，查看崩溃日志，却往往得不到有用的栈信息。还好，有一个方法用来解决这个问题：NSZombieEnabled。 这是一个环境变量，用来调试与内存相关的问题，跟踪对象的释放过程。启用了NSZombieEnabled的话，它会用一个僵尸实现来去你的默认的dealloc实现，也就是在引用计数降到0时，该僵尸实现会将该对象转换成僵尸对象。僵尸对象的作用是在你向它发送消息时，它会显示一段日志并自动跳入调试器。 所以，当在应用中启用NSZombie而不是让应用直接崩溃时，一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象。僵尸对象会显示接收到的消息，然后跳入调试器，这样你就可以查看到底哪时出了问题。 可以在Xcode的scheme页面中设置NSZombieEnabled环境变量。点击Product-Edit Scheme打开该页面，然后勾选Enable Zombie Objects复选框，如图所示： 僵尸在RAC出现以前作用很大。但自从有了ARC，如果你在对象的所有权方面比较注意，那么通常不会碰到内存相关的崩溃。 SIGSEGV段错误信息（SIGSEGV）是操作系统产生的一个更严重的问题。当硬件出现错误、访问不可读的内存地址或向受保护的内存地址写入数据时，就会发生这个错误。 硬件错误这一情况并不常见。当要读取保存在RAM中的数据，而该位置的RAM硬件有问题时，你会收到SIGSEGV。SIGSEGV更多是出现在后两种情况。默认情况下，代码页不允许进行写操作，而数据而不允许进行执行操作。当应用中的某个指针指向代码页并试图修改指向位置的值时，你会收到SIGSEGV。当要读取一个指针的值，而它被初始化成指向无效内存地址的垃圾值时，你也会收到SIGSEGV。 SIGSEGV错误调试起来更困难，而导致SIGSEGV的最常见原因是不正确的类型转换。要避免过度使用指针或尝试手动修改指针来读取私有数据结构。如果你那样做了，而在修改指针时没有注意内存对齐和填充问题，就会收到SIGSEGV。 SIGBUS总线错误信号（SIGBUG）代表无效内存访问，即访问的内存是一个无效的内存地址。也就是说，那个地址指向的位置根本不是物理内存地址（它可能是某个硬件芯片的地址）。SIGSEGV和SIGBUS都羽毛球EXC_BAD_ACCESS的子类型。 SIGTRAPSIGTRAP代表陷阱信号。它并不是一个真正的崩溃信号。它会在处理器执行trap指令发送。LLDB调试器通常会处理此信号，并在指定的断点处停止运行。如果你收到了原因不明的SIGTRAP，先清除上次的输出，然后重新进行构建通常能解决这个问题。 EXC_ARITHETIC当要除零时，应用会收到EXC_ARITHMETIC信号。这个错误应该很容易解决。 SIGILLSIGILL代表signal illegal instruction(非法指令信号)。当在处理器上执行非法指令时，它就会发生。执行非法指令是指，将函数指针会给另外一个函数时，该函数指针由于某种原因是坏的，指向了一段已经释放的内存或是一个数据段。有时你收到的是EXC_BADINSTRUCTION而不是SIGILL，虽然它们是一回事，不过EXC*等同于此信号不依赖体系结构。 SIGABRTSIGABRT代表SIGNAL ABORT（中止信号）。当操作系统发现不安全的情况时，它能够对这种情况进行更多的控制；必要的话，它能要求进程进行清理工作。在调试造成此信号的底层错误时，并没有什么妙招。Cocos2d或UIKit等框架通常会在特定的前提条件没有满足或一些糟糕的情况出现时调用C函数abort（由它来发送此信号）。当SIGABRT出现时，控制台通常会输出大量的信息，说明具体哪里出错了。由于它是可控制的崩溃，所以可以在LLDB控制台上键入bt命令打印出回溯信息。 看门狗超时这种崩溃通常比较容易分辨，因为错误码是固定的0x8badf00d。（程序员也有幽默的一面，他们把它读作Ate Bad Food。）在iOS上，它经常出现在执行一个同步网络调用而阻塞主线程的情况。因此，永远不要进行同步网络调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSTimer 小结]]></title>
      <url>%2F2015%2F09%2F12%2FNSTimer%2F</url>
      <content type="text"><![CDATA[NSTimer 常用的方法有三个 123+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;- (instancetype)initWithFireDate:(NSDate *)date interval:(NSTimeInterval)ti target:(id)t selector:(SEL)s userInfo:(nullable id)ui repeats:(BOOL)rep; scheduledTimerWithTimeInterval 是创建一个定时器，并加入到当前运行循环[NSRunLoop currentRunLoop]中，而其他两个只是创建定时器，并未添加到当前运行循环中，所以如果是其他两种方式创建的定时器则需要手动添加到currentRunLoop中，示例代码如下： 12345NSTimer *timer1 = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(doSomeThing1) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer1 forMode:NSDefaultRunLoopMode]; NSTimer *timer2 = [[NSTimer alloc] initWithFireDate:[NSDate dateWithTimeIntervalSinceNow:5] interval:3 target:self selector:@selector(doSomeThing2) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer2 forMode:NSDefaultRunLoopMode]; 关于fire方法并不是启动一个定时器，只是提前触发而已，详情可查看苹果文档 fire: You can use this method to fire a repeating timer without interrupting its regular firing schedule. If the timer is non-repeating, it is automatically invalidated after firing, even if its scheduled fire date has not arrived. 定时器如果不再使用的话，需要手动释放，直接调用invalidate即可，千万不要放在dealloc里面调用invalidate，原因我就不说了，不懂可以google invalidate: This method is the only way to remove a timer from an NSRunLoop object. The NSRunLoop object removes its strong reference to the timer, either just before the invalidate method returns or at some later point. If it was configured with target and user info objects, the receiver removes its strong references to those objects as well.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[addObserverForName 使用注意事项]]></title>
      <url>%2F2015%2F08%2F09%2FaddObserverForName%2F</url>
      <content type="text"><![CDATA[避免使用addObserverForName方法给自己埋坑 挖坑准备工作之前使用通知喜欢直接在viewDidLoad里面添加下面方法 1- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject; 在dealloc方法里也习惯添加 1[[NSNotificationCenter defaultCenter] removeObserver:self]; 来释放监听的对象 但是这种方法不是很直观,所以后来想用通知的block方法，由于使用不规范，埋下了很多坑，现在来填坑。先说下坑在哪里，通知的block方法如下： 1- (id &lt;NSObject&gt;)addObserverForName:(nullable NSString *)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block 挖坑过程在viewDidLoad直接使用上述block方法，不接收其返回值，在dealloc方法里面只添加 1[[NSNotificationCenter defaultCenter] removeObserver:self]; 挖坑结果发出一个通知，可以接收到多次 填坑攻略我还是用代码来展示吧，先定义一个 id 对象 observer 用来接收block方法的返回值 1234observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"notificationName" object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *note) &#123; // do anything &#125;]; 释放的时候直接removeObserver:self是没有效果的，而应该使用下列方法 123456- (void)dealloc&#123; if (observer) &#123; [[NSNotificationCenter defaultCenter] removeObserver:observer]; &#125;&#125; 总结addObserverForName和 addObserver的释放是不一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何将数组/字典中的数据保存到plist文件中]]></title>
      <url>%2F2015%2F07%2F10%2FHow-to-write-object-in-file%2F</url>
      <content type="text"><![CDATA[以前总觉得将内容写入文件是多么高大上的功能，在iOS里面，其实只需要一个关键方法 1- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile; 即可实现该功能。 如何写文件该方法其实是NSArray和NSDictionary的实例方法，新手尝尝遇到的问题就是虽然用到了上述方法，但是最终写入文件失败了，失败的原因大多数就是： 要写入内容的文件是否存在（若不存在需要调用-[NSFileManager createFileAtPath:contents:attributes:]来创建文件） 要写入内容的文件已存在，但是文件路径写错了 废话不多说，附上我测试code: 1234567891011121314151617181920212223242526- (void)writeToFile&#123; NSDictionary *dict = @&#123;@"A":@[@"1",@"2",@"3"], @"B":@[@"4",@"5",@"6"], @"C":@[@"7",@"8",@"9"]&#125;; NSArray *array = @[@"A",@"B",@"C",@"D",@"E",@"F",@"G"]; //把数据保存到沙盒里的plist文件 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *plistPath = [paths objectAtIndex:0]; NSLog(@"%@",plistPath); //得到完整的路径名 NSString *fileName1 = [plistPath stringByAppendingPathComponent:@"test1.plist"]; NSString *fileName2 = [plistPath stringByAppendingPathComponent:@"test2.plist"]; NSFileManager *fm = [NSFileManager defaultManager]; if ([fm createFileAtPath:fileName1 contents:nil attributes:nil]) &#123; [array writeToFile:fileName1 atomically:YES]; NSLog(@"文件1写入完成"); &#125; if ([fm createFileAtPath:fileName2 contents:nil attributes:nil]) &#123; [dict writeToFile:fileName2 atomically:YES]; NSLog(@"文件2写入完成"); &#125;&#125; ## 如何读文件首先需要知道你写入文件的数据的类型是什么，是字符串，一个数组，一个字典还是NSData，知道了这些，我们就可以用相应的类方法 xxxWithContentsOfFile: 来获取文件内容。 // 从文件中读取字符串，txtPath为字符串文件路径 NSString *resultStr = [NSString stringWithContentsOfFile:txtPath encoding:NSUTF8StringEncoding error:nil]; // 从文件中读取数据数组的方法,filePath为数组文件路径 NSArray *resultArr = [NSArray arrayWithContentsOfFile:filePath]; // 从文件中读取数据字典的方法，fileDicPath为字典文件路径 NSDictionary *resultDic = [NSDictionary dictionaryWithContentsOfFile:fileDicPath]; // 从文件读取存储的NSData数据，fileDataPath为数据文件路径 NSData *resultData = [NSData dataWithContentsOfFile:fileDataPath]; 扩展资料 文件操作（NSFileManager） 数据处理之文件读写]]></content>
    </entry>

    
  
  
</search>
